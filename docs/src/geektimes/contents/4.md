# [浏览器工作原理与实践](https://time.geekbang.org/column/intro/100033601?tab=catalog)

:::details 专栏目录
![专栏目录](https://static001.geekbang.org/resource/image/9b/92/9ba059d108b7e84479f2e57d90280892.jpg?wh=750*3557)
:::

[Github - chromium](https://github.com/chromium/chromium)

## 开篇词
### [开篇词 | 参透了浏览器的工作原理，你就能解决80%的前端难题](https://time.geekbang.org/column/article/113399)
**浏览器发展历程3个大的进化路线：**

* 应用程序Web化（视频、音频、游戏等往Web的使用场景切换）
* Web应用移动化（[PWA](https://developer.mozilla.org/zh-CN/docs/Web/Progressive_web_apps)）
* Web操作系统化
  * 利用Web技术构建一个纯粹的操作系统，如 [ChromeOS](https://zh.wikipedia.org/wiki/ChromeOS)
  * 浏览器的底层结构往操作系统架构方向发展
    * Chrome 朝着 SOA 的方向演化，未来很多模块都会以服务的形式提供给上层应用使用；
    * 在浏览器中引入多种编程语言的支持，比如新支持的 [MDN - WebAssembly](https://developer.mozilla.org/zh-CN/docs/WebAssembly)；
    * 简化渲染流程，使得渲染过程更加直接高效；
    * 加大对系统设备特性的支持；
    * 提供对复杂 Web 项目开发的支持。

**为什么要学习浏览器工作原理？**

1. 准确评估 Web 开发项目的可行性
2. 从更高维度审视页面
  要能站在用户体验角度来考虑页面性能：页面加载时长、用户交互反馈时长、Web动画中的帧数。
3. 在快节奏的技术迭代中把握本质
  前端技术是如何针对一些核心诉求做演进的？
    1. 脚本执行速度问题
      * 不断修订和更新语言本身 (ES6、ES7、ES8，或者 TypeScript 出现的必要性)
      * 颠覆性地使用新的语言，这就是 WebAssembly 出现的原因。
    2. 前端模块化开发
      出现了 WebComponents 标准。React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。

      如果理解了浏览器工作原理，那么对 WebComponents 中涉及的 Shadow DOM、HTML Templates 等技术也会有更深刻的理解。
    3. 渲染效率问题
      理解浏览器渲染流程，就会知道渲染存在的缺陷，从而知道如何避免。

      与此同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。
        * [揭秘 Chromium 渲染引擎（一）：RenderingNG](https://zhuanlan.zhihu.com/p/438734215)
        * [RenderingNG deep-dive: LayoutNG](https://developer.chrome.com/articles/layoutng/)
        * [RenderingNG deep-dive: BlinkNG](https://developer.chrome.com/articles/blinkng/)

## 宏观视角下的浏览器
### [01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？](https://time.geekbang.org/column/article/113513)
Chrome打开一个页面需要启动多少进程？ 点击 **窗口 -> 任务管理器** 

##### 线程 VS 进程
线程是不能单独存在的，它由进程来启动和管理。

一个进程是一个程序的运行实例。

线程依附于进程，进程中使用多线程并行处理能提升运算效率。

进程和线程之间的4个特点：
1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

##### 单进程浏览器时代
浏览器的所有功能模块都是运行在同一个进程里。
存在3个问题：
1. 不稳定（插件、渲染引擎模块）
2. 不流畅（脚本、插件、页面内存泄漏）
3. 不安全（C/C++插件、页面脚本）

##### 多进程浏览器时代
![早期](https://static001.geekbang.org/resource/image/cd/60/cdc9215e6c6377fc965b7fac8c3ec960.png?wh=1142*725)

##### 目前多进程架构
![目前](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png?wh=1142*494)

##### 面向未来服务的架构
![未来-资源不受限](https://static001.geekbang.org/resource/image/32/2a/329658fe821252db47b0964037a1de2a.png?wh=1142*582)
![未来-资源受限](https://static001.geekbang.org/resource/image/a9/76/a9ba86d7b03263fa3997d3733d958176.png?wh=1142*630)

### [02 | TCP协议：如何保证页面文件能被完整送达浏览器？](https://time.geekbang.org/column/article/113550)
> FP (First Paint): 从页面加载到首次开始绘制的时长。影响FP的一个重要因素是：**网络加载速度**。
##### 一个数据包的“旅程”
1. IP: 把数据包送达目的主机
2. UDP: 把数据包送达应用程序（不保证数据传输的可靠性，但速度快）
3. TCP: 把数据完整地送达应用程序（重传机制；排序机制）
  一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。

  TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

##### 网络协议相关专栏推荐
* [极客时间 - 透视 HTTP 协议](https://time.geekbang.org/column/intro/100029001?tab=catalog)
* [极客时间 - 趣谈网络协议](https://time.geekbang.org/column/intro/100007101?tab=catalog)
* [极客时间 - Web 协议详解与抓包实战](https://time.geekbang.org/course/intro/100026801?tab=catalog)

### [03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？](https://time.geekbang.org/column/article/116588)
##### 浏览器发起HTTP请求流程
1. 构建请求
2. 查找缓存（浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术）
3. 准备IP地址和端口
4. 等待TCP队列（Chrome的机制：同一域名最多建立6个TCP连接，多余的排队等待）
5. 建立TCP连接
6. 发送HTTP请求
##### 服务器端处理HTTP请求流程
1. 返回请求
2. 断开连接
3. 重定向
##### 为什么很多站点第二次打开速度会很快？
**因为缓存**。 这里的缓存是：**DNS缓存**和**页面资源缓存**。
![资源缓存](https://static001.geekbang.org/resource/image/5f/08/5fc2f88a04ee0fc41a808f3481287408.png?wh=1142*1258)
参考资料：[HTTP缓存](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching)
##### 登录状态是如何保存的？
![登录状态保存](https://static001.geekbang.org/resource/image/d9/b3/d9d6cefe8d3d6d84a37a626687c6ecb3.png?wh=1142*932)
##### HTTP请求流程示意图
![示意图](https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png?wh=1142*423)

### [04 | 导航流程：从输入URL到页面展示，这中间发生了什么？](https://time.geekbang.org/column/article/117637)
##### 从输入URL到页面展示
![完整流程示意图](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png?wh=1142*478)
1. 用户输入（页面内容的替换需要等待提交文档阶段）
    * 如果是搜索内容，浏览器根据搜索词合成URL
    * 如果是URL，浏览器拼上协议，合成URL
2. URL请求过程
    浏览器进程通过进程间通信把URL请求发送到网络进程，由网络进程发起真正的网络请求。
    * 查找缓存，有就使用，没有继续下面流程
    * DNS解析，如果需要
    * 如果是HTTPS，建立TLS链接
    * 建立TCP链接
    * 构建请求信息，发送请求
    * 网络进程收到响应头、响应行，响应体，进行解析
    * 导航流程结束
3. 准备渲染进程
    浏览器为每个页面单独分配一个进程，但是同源的会进行复用。
4. 提交文档
    浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程.
    * 当浏览器进程接收到网络进程的响应头数据之后，便向渲染进程发起“提交文档”的消息；
    * 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”；
    * 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程；
    * 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

    到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。
5. 渲染阶段（见05、06）
    渲染进程开始页面解析和子资源加载。
    一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。

### [05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？](https://time.geekbang.org/column/article/118205)
### [06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？](https://time.geekbang.org/column/article/118826)
导航被提交后，就会进入渲染阶段。
渲染流水线分为：
  1. 构建DOM树
  2. 样式计算
      * CSS转换为浏览器能理解的结构styleSheets（document.styleSheets）
      * 转换样式表中的属性值，使其标准化（2em -> xxpx、red -> rgb(255,0,0)）
      * 计算出 DOM 树中每个节点的具体样式（涉及CSS继承规则、层叠规则）
  3. 布局阶段
    布局：计算DOM树中可见元素的几何位置的过程。包含：
      * 创建布局树
      * 布局计算
  4. 分层
      渲染引擎需要为特定的节点（复杂的3D变换、z-indexing等）生成专用的图层，并生成一棵对应的图层树（LayerTree）。

      浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
      ![布局树和图层树](https://static001.geekbang.org/resource/image/e8/61/e8a7e60a2a08e05239456284d2aa4061.png?wh=1142*674)

      通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层:
        * 拥有层叠上下文属性的元素会被提升为单独的一层。（定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context)属性。）
    
        * 需要剪裁（clip）的地方也会被创建为图层。

  5. 图层绘制
    在图层绘制阶段，输出的内容就是待绘制列表。
  6. 栅格化（raster）操作
    绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。
    合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。
    ![图层被划分为图块](https://static001.geekbang.org/resource/image/bc/52/bcc7f6983d5ece8e2dd716f431d0e052.png?wh=1142*995)
  7. 合成和显示
    一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

3个和渲染流水线相关的概念：
1. 重排：更新了元素的几何属性
2. 重绘：更新了元素的绘制属性
3. 直接合成阶段：
  ![避开重排和重绘](https://static001.geekbang.org/resource/image/02/2c/024bf6c83b8146d267f476555d953a2c.png?wh=1142*270)

### 问题整理
##### 1. 你认为现代的前端工程师需要具备哪些核心的基础技能呢？
1. 必备技能，核心能力：
    1. html: 语义标签
    2. css: 编译语言sass,less，常见响应式布局：栅格、flex。业界典型的框架bootstrap、bulma、Material
    3. js: modular思想，spa思想，跨平台js代码的编写，以及打包工具
    4. 用户交互体验，数据可视化
2. 工程化 nodejs
3. 浏览器原理
##### 2. 回顾浏览器的进化路线，你认为推动浏览器发展的主要动力是什么？
    1. 为了更稳定、为了更流程、为了更安全。
    2. 将之前复杂的设计情拆分得更小，便于更有针对性的进行完善。（即简化设计，方便扩展）
##### 3. 你是怎么理解HTTP和TCP的关系？
  网络协议是分层的，HTTP在TCP上层，HTTP利用TCP提供的服务，进行数据的传输。
  评论中一个更形象的回答：TCP是个梯子，HTTP就是利用梯子来搬运货物。
##### 4. 如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？
  评论中mfist的回答：
    1. 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过ping curl看看对应的时延高不高。
    2. 然后通过wireshake看看具体哪里出了问题。
    3. 假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。
##### 5. 从输入 URL 到页面展示，这中间发生了什么？
##### 6. 如果下载 CSS 文件阻塞了，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？
##### 7. 为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？

### 书籍推荐
1. 《Webkit技术内幕》